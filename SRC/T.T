!! DO NOT EDIT THIS FILE, EDIT TSOURCE.T INSTEAD !!

! T3X -> DOS/8086 compiler
! Nils M Holm, 2017,2019,2020,2021,2022
! Humberto Costa dos Santos Junior, 2022
! Public Domain / 0BSD license

module t3x86(t3x);

object  t[t3x];

const   BPW = 2;

const   GPOOL_SIZE = 7;

const   BUFLEN = 512;

const   SYMTBL_SIZE = 2048;
const   LABEL_SIZE = 2048;
const   NLIST_SIZE = 6144;
const   FWDCL_SIZE = 128;

var     Outname::80;

var     Line;

var     Verbose;

const   ENDFILE = %1;
const   EOFCHAR = 0x1a;

var ntoa_buf::100;

ntoa(x) do var i, k;
	if (x = 0) return "0";
	i := 0;
	k := x<0-> -x: x;
	while (k > 0) do
		i := i+1;
		k := k/10;
	end
	i := i+1;
	if (x < 0) i := i+1;
	ntoa_buf::i := 0;
	k := x<0-> -x: x;
	while (k > 0) do
		i := i-1;
		ntoa_buf::i := '0' + k mod 10;
		k := k/10;
	end
	if (x < 0) do
		i := i-1;
		ntoa_buf::i := '-';
	end
	return @ntoa_buf::i;
end

str_length(s) return t.memscan(s, 0, 32767);

str_copy(sd, ss) t.memcopy(sd, ss, str_length(ss)+1);

str_append(sd, ss) t.memcopy(@sd::str_length(sd), ss, str_length(ss)+1);

str_equal(s1, s2) return t.memcomp(s1, s2, str_length(s1)+1) = 0;

writes(s) t.write(1, s, str_length(s));

nl() do var b::3;
	writes(t.newline(b));
end

aw(m, s) do
	writes("Error: ");
	writes(ntoa(Line));
	writes(": ");
	writes(m);
	if (s \= 0) do
		writes(": ");
		writes(s);
	end
	nl();
	if (Outname::0) t.remove(Outname);
	halt 1;
end

oops(m, s) do
	writes("Internal error");
	nl();
	aw(m, s);
end

numeric(c) return '0' <= c /\ c <= '9';

alphabetic(c) return 'a' <= c /\ c <= 'z' \/
		     'A' <= c /\ c <= 'Z';

!
! Symbol tables
!

struct  SYM = SNAME, SFLAGS, SVALUE;

const   GLOB = 1;
const   CNST = 2;
const   VECT = 4;
const   FORW = 8;
const   FUNC = 16;
const   FUNCF = 32;
const   FUNCI = 64;

var     Syms[SYM*SYMTBL_SIZE];
var     Labels[LABEL_SIZE];
Var     Lab;
var     Nlist::NLIST_SIZE;

var     Yp, Np;

var     Fwlab[FWDCL_SIZE],
	Fwaddr[FWDCL_SIZE];
var     Fwp;

find(s) do var i;
	i := Yp-SYM;
	while (i >= 0) do
		if (str_equal(Syms[i+SNAME], s))
			return @Syms[i];
		i := i - SYM;
	end
	return 0;
end

lookup(s, f) do var y;
	y := find(s);
	if (y = 0) aw("undefined", s);
	if (y[SFLAGS] & f \= f)
		aw("unexpected type", s);
	return y;
end

newname(s) do var k, new;
	k := str_length(s)+1;
	if (Np+k >= NLIST_SIZE)
		aw("name pool overflow", s);
	new := @Nlist::Np;
	t.memcopy(new, s, k);
	Np := Np+k;
	return new;
end

add(s, f, v) do var y;
	y := find(s);
	if (y \= 0) do
		ie (y[SFLAGS] & FORW /\ f & FUNC)
			return y;
		else
			aw("redefined", s);
	end
	if (Yp+SYM >= SYMTBL_SIZE*SYM)
		aw("too many symbols", 0);
	y := @Syms[Yp];
	Yp := Yp+SYM;
	y[SNAME] := newname(s);
	y[SFLAGS] := f;
	y[SVALUE] := v;
	return y;
end

addfwd(l, a) do
	if (Fwp >= FWDCL_SIZE)
		aw("too many forward declarations", 0);
	Fwlab[Fwp] := l;
	Fwaddr[Fwp] := a;
	Fwp := Fwp+1;
end

!
! Emitter
!

var     Pass;

var     Outfile;
var     Outbuf::BUFLEN;
var     Outp;

var     Gp, Gtop;

var     Tp, Dp, Lp, Ls, Lp0, Lbp0;

var     Acc;

var     Codetbl;

struct  OPT = OINST1, OARG, OINST2, OREPL;

var     Opttbl;

struct  CG =    CG_NULL,
		CG_PUSH, CG_CLEAR, CG_DROP,
		CG_LDVAL, CG_LDADDR, CG_LDLREF, CG_LDGLOB,
		CG_LDLOCL,
		CG_STGLOB, CG_STLOCL, CG_STINDR, CG_STINDB,
		CG_INCGLOB, CG_INCLOCL, CG_INCR,
		CG_STACK, CG_UNSTACK, CG_LOCLVEC, CG_GLOBVEC,
		CG_INDEX, CG_DEREF, CG_INDXB, CG_DREFB,
		CG_CALL, CG_CALR, CG_CALRF, CG_JUMP, CG_RJUMP, CG_JMPFALSE,
		CG_JMPTRUE, CG_FOR, CG_FORDOWN, CG_MKFRAME,
		CG_DELFRAME, CG_RET, CG_RETF, CG_IRET, CG_HALT,
		CG_NEG, CG_INV, CG_LOGNOT, CG_ADD, CG_SUB,
		CG_MUL, CG_DIV, CG_MOD, CG_AND, CG_OR, CG_XOR,
		CG_SHL, CG_SHR, CG_EQ, CG_NE, CG_LT, CG_GT,
		CG_LE, CG_GE, CG_JMPEQ, CG_JMPNE, CG_JMPLT,
		CG_JMPGT, CG_JMPLE, CG_JMPGE, CG_PUSHA, CG_POPA, CG_DIVU;

findlab(id) return Labels[id];

newlab() do
	if (Lab >= LABEL_SIZE) aw("too many labels", 0);
	Lab := Lab+1;
	return Lab-1;
end

decl    commit(0);

resolve(id) do
	commit();
	Labels[id] := Tp;
end

resolve_fwd(a) do var i;
	i := 0;
	while (i < Fwp) do
		if (Fwaddr[i] = a) do
			resolve(Fwlab[i]);
			return;
		end
		i := i+1;
	end
	oops("unknown forward reference", 0);
end

flush() do
	if (\Outp) return;
	if (t.write(Outfile, Outbuf, Outp) \= Outp)
		aw("file write error", 0);
	Outp := 0;
end

emit(x) do
	Tp := Tp+1;
	if (Pass = 0) return;
	if (Outp >= BUFLEN) flush();
	Outbuf::Outp := x;
	Outp := Outp + 1;
end

emitw(x) do
	emit(255 & x);
	emit(255 & (x>>8));
end

hex(c)  ie (numeric(c))
		return c-'0';
	else
		return c-'a'+10;

byte(s) return 16*hex(s::0) + hex(s::1);

rgen(s, v) do var n;
	while (s::0) do
		ie (s::0 = ',') do
			ie (s::1 = 'w')
				emitw(v);
			else ie (s::1 = 'l')
				emit(v);
			else ie (s::1 = 'h')
				emit(v+1);
			else ie (s::1 = 'r')
				emitw(v-Tp-2);
			else ie (s::1 = 'R') do
				n := byte(s+4) << 8 | byte(s+2);
				emitw(n-Tp-2);
				s := s+4;
			end
			else ie (s::1 = 'b')
				emit(v);
			else
				oops("bad code", 0);
		end
		else do
			emit(byte(s));
		end
		s := s+2;
	end
end

var     Qi, Qa;

commit() do
	rgen(Codetbl[Qi][1], Qa);
	Qi := CG_NULL;
end

gen(id, a) do var i, skiparg;
	skiparg := %1;
	i := 0;
	while (Opttbl[i] \= %1) do
		ie (Opttbl[i][OINST1] = %1)
			skiparg := 0;
		else if (Qi = Opttbl[i][OINST1] /\
			 id = Opttbl[i][OINST2] /\
			 (skiparg \/ Qa = Opttbl[i][OARG]))
		do
			Qi := Opttbl[i][OREPL];
			Qa := a;
			return;
		end
		i := i+1;
	end
	if (Qi \= CG_NULL) commit();
	Qi := id;
	Qa := a;
end

spill() ie (Acc)
		gen(CG_PUSH, 0);
	else
		Acc := 1;

active() return Acc;

clear() Acc := 0;

activate() Acc := 1;

builtin(name, arity, a)
	add(name, GLOB|FUNC | (arity << 8), a);

globaddr() do var l, i, g;
	if (Gp >= Gtop) do
		gen(CG_RJUMP, GPOOL_SIZE*2);
		commit();
		Gp := Tp;
		for (i=0, GPOOL_SIZE) emitw(0);
		Gtop := Tp;
	end
	g := Gp;
	Gp := Gp+2;
	return g;
end

align(x, a) return (x+a) & ~(a-1);

!
! Scanner
!

const   META     = 256;

const   TOKEN_LEN = 128;

var     Infile;
var     Inbuf::BUFLEN;
var     Ip, Ep;
var     Rejected;
var     Tk;
var     Str::TOKEN_LEN;
var     Val;
var     Oid;

var     Equal_op, Minus_op, Mul_op, Add_op;

struct  OPER = OPREC, OLEN, ONAME, OTOK, OCODE;

var     Ops;

struct  TOKENS =
	SYMBOL, INTEGER, STRING,
	ADDROF, ASSIGN, BINOP, BYTEOP, COLON, COMMA, COND,
	CONJ, DISJ, LBRACK, LPAREN, RBRACK, RPAREN, SEMI, UNOP,
	KCALL, KCONST, KDECL, KDO, KELSE, KEND, KFOR, KHALT, KIE,
	KIF, KLEAVE, KLOOP, KMODULE, KOBJECT, KPACKED, KRETURN,
	KSTRUCT, KVAR, KWHILE, KFAR, KFINT, KCALLFAR;

readrc() do var c;
	if (Rejected) do
		c := Rejected;
		Rejected := 0;
		return c;
	end
	if (Ip >= Ep) do
		Ep := t.read(Infile, Inbuf, BUFLEN);
		Ip := 0;
	end
	if (Ip >= Ep) return ENDFILE;
	c := Inbuf::Ip;
	Ip := Ip+1;
	return c;
end

readc() do var c;
	c := readrc();
	return 'A' <= c /\ c <= 'Z'-> c-'A'+'a': c;
end

readec() do var c;
	c := readrc();
	if (c \= '\\') return c;
	c := readrc();
	if (c = 'a') return '\a';
	if (c = 'b') return '\b';
	if (c = 'e') return '\e';
	if (c = 'f') return '\f';
	if (c = 'n') return '\n';
	if (c = 'q') return '"' | META;
	if (c = 'r') return '\r';
	if (c = 's') return '\s';
	if (c = 't') return '\t';
	if (c = 'v') return '\v';
	return c;
end

reject(c) Rejected := c;

skip() do var c;
	c := readc();
	while (1) do
		while (c = ' ' \/ c = '\t' \/ c = '\n' \/ c = '\r') do
			if (c = '\n') Line := Line+1;
			c := readc();
		end
		if (c \= '!')
			return c;
		while (c \= '\n' /\ c \= ENDFILE)
			c := readc();
	end
end

findkw(s) do
	if (s::0 = 'c') do
		if (str_equal(s, "callfar")) return KCALLFAR;
		if (str_equal(s, "call")) return KCALL;
		if (str_equal(s, "const")) return KCONST;
		return 0;
	end
	if (s::0 = 'd') do
		if (str_equal(s, "do")) return KDO;
		if (str_equal(s, "decl")) return KDECL;
		return 0;
	end
	if (s::0 = 'e') do
		if (str_equal(s, "else")) return KELSE;
		if (str_equal(s, "end")) return KEND;
		return 0;
	end
	if (s::0 = 'f') do
		if (str_equal(s, "for")) return KFOR;
		if (str_equal(s, "farint")) return KFINT;
		if (str_equal(s, "far")) return KFAR;
		return 0;
	end
	if (s::0 = 'h') do
		if (str_equal(s, "halt")) return KHALT;
		return 0;
	end
	if (s::0 = 'i') do
		if (str_equal(s, "if")) return KIF;
		if (str_equal(s, "ie")) return KIE;
		return 0;
	end
	if (s::0 = 'l') do
		if (str_equal(s, "leave")) return KLEAVE;
		if (str_equal(s, "loop")) return KLOOP;
		return 0;
	end
	if (s::0 = 'm') do
		if (str_equal(s, "mod")) return BINOP;
		if (str_equal(s, "module")) return KMODULE;
		return 0;
	end
	if (s::0 = 'o') do
		if (str_equal(s, "object")) return KOBJECT;
		return 0;
	end
	if (s::0 = 'p') do
		if (str_equal(s, "packed")) return KPACKED;
		return 0;
	end
	if (s::0 = 'r') do
		if (str_equal(s, "return")) return KRETURN;
		return 0;
	end
	if (s::0 = 's') do
		if (str_equal(s, "struct")) return KSTRUCT;
		return 0;
	end
	if (s::0 = 'v') do
		if (str_equal(s, "var")) return KVAR;
		return 0;
	end
	if (s::0 = 'w') do
		if (str_equal(s, "while")) return KWHILE;
		return 0;
	end
	return 0;
end

scanop(c) do var i, j;
	i := 0;
	j := 0;
	Oid := %1;
	while (Ops[i][OLEN] > 0) do
		ie (Ops[i][OLEN] > j) do
			if (Ops[i][ONAME]::j = c) do
				Oid := i;
				Str::j := c;
				c := readc();
				j := j+1;
			end
		end
		else do
			leave;
		end
		i := i+1;
	end
	if (Oid = %1) do
		Str::j := c;
		j := j+1;
		Str::j := 0;
		aw("unknown operator", Str);
	end
	Str::j := 0;
	reject(c);
	return Ops[Oid][OTOK];
end

findop(s) do var i;
	i := 0;
	while (Ops[i][OLEN] > 0) do
		if (str_equal(s, Ops[i][ONAME])) do
			Oid := i;
			return Oid;
		end
		i := i+1;
	end
	oops("operator not found", s);
end

symbolic(c) return alphabetic(c) \/ c = '_' \/ c = '.';

scan() do var c, i, k, sgn, base;
	c := skip();
	if (c = ENDFILE \/ c = EOFCHAR) do
		str_copy(Str, "end of file");
		return ENDFILE;
	end
	if (symbolic(c)) do
		i := 0;
		while (symbolic(c) \/ numeric(c)) do
			if (i >= TOKEN_LEN-1) do
				Str::i := 0;
				aw("symbol too long", Str);
			end
			Str::i := c;
			i := i+1;
			c := readc();
		end
		Str::i := 0;
		reject(c);
		k := findkw(Str);
		if (k \= 0) do
			if (k = BINOP) findop(Str);
			return k;
		end
		return SYMBOL;
	end
	if (numeric(c) \/ c = '%') do
		sgn := 1;
		i := 0;
		if (c = '%') do
			sgn := %1;
			c := readc();
			Str::i := c;
			i := i+1;
			if (\numeric(c))
				aw("missing digits after '%'", 0);
		end
		base := 10;
		if (c = '0') do
			c := readc();
			if (c = 'x') do
				base := 16;
				c := readc();
				if (\numeric(c) /\ (c < 'a' \/ c > 'f'))
					aw("missing digits after '0x'", 0);
			end
		end
		Val := 0;
		while ( numeric(c) \/
			base = 16 /\ 'a' <= c /\ c <= 'f'
		) do
			if (i >= TOKEN_LEN-1) do
				Str::i := 0;
				aw("integer too long", Str);
			end
			Str::i := c;
			i := i+1;
			c := c >= 'a'-> c-'a'+10: c-'0';
			Val := Val * base + c;
			c := readc();
		end
		Str::i := 0;
		reject(c);
		Val := Val * sgn;
		return INTEGER;
	end
	if (c = '\'') do
		Val := readec();
		if (readc() \= '\'')
			aw("missing ''' in character", 0);
		return INTEGER;
	end
	if (c = '"') do
		i := 0;
		c := readec();
		while (c \= '"' /\ c \= ENDFILE) do
			if (i >= TOKEN_LEN-1) do
				Str::i := 0;
				aw("string too long", Str);
			end
			Str::i := c & (META-1);
			i := i+1;
			c := readec();
		end
		Str::i := 0;
		return STRING;
	end
	return scanop(c);
end

!
! Parser
!

const   MAXTBL   = 128;
const   MAXLOOP  = 100;

var     Retlab;
var     Rettype;
var     Frame;
var     Loop0;
var     Leaves[MAXLOOP], Lvp;
var     Loops[MAXLOOP], Llp;

expect(tok, s) do var b::100;
	if (tok = Tk) return;
	str_copy(b, s);
	str_append(b, " expected");
	aw(b, Str);
end

xeqsign() do
	if (Tk \= BINOP \/ Oid \= Equal_op)
		expect(BINOP, "'='");
	Tk := scan();
end

xsemi() do
	expect(SEMI, "';'");
	Tk := scan();
end

xlparen() do
	expect(LPAREN, "'('");
	Tk := scan();
end

xrparen() do
	expect(RPAREN, "')'");
	Tk := scan();
end

xsymbol() expect(SYMBOL, "symbol");

constfac() do var v, y;
	if (Tk = INTEGER) do
		v := Val;
		Tk := scan();
		return v;
	end
	if (Tk = SYMBOL) do
		y := lookup(Str, CNST);
		Tk := scan();
		return y[SVALUE];
	end
	aw("constant value expected", Str);
end

constval() do var v;
	v := constfac();
	ie (Tk = BINOP /\ Oid = Mul_op) do
		Tk := scan();
		v := v * constfac();
	end
	else if (Tk = BINOP /\ Oid = Add_op) do
		Tk := scan();
		v := v + constfac();
	end
	return v;
end

checklocal(y)
	if (y[SVALUE] > 126 \/ y[SVALUE] < -126)
		aw("local storage exceeded", y[SNAME]);

vardecl(glb) do var y, size, a;
	Tk := scan();
	while (1) do
		xsymbol();
		ie (glb & GLOB) do
			a := globaddr();
			y := add(Str, glb, a);
		end
		else do
			y := add(Str, 0, Lp);
		end
		Tk := scan();
		size := 1;
		ie (Tk = LBRACK) do
			Tk := scan();
			size := constval();
			if (size < 1)
				aw("invalid size", 0);
			y[SFLAGS] := y[SFLAGS] | VECT;
			expect(RBRACK, "']'");
			Tk := scan();
		end
		else if (Tk = BYTEOP) do
			Tk := scan();
			size := constval();
			if (size < 1)
				aw("invalid size", 0);
			size := (size + BPW-1) / BPW;
			y[SFLAGS] := y[SFLAGS] | VECT;
		end
		ie (glb & GLOB) do
			if (y[SFLAGS] & VECT) do
				gen(CG_STACK, -(size*BPW));
				Dp := Dp + size*BPW;
				gen(CG_GLOBVEC, a);
			end
		end
		else do
			ie (y[SFLAGS] & VECT) do
				gen(CG_STACK, -((Ls+size)*BPW));
				Lp := Lp - size*BPW;
				Ls := 0;
				gen(CG_LOCLVEC, 0);
			end
			else do
				Ls := Ls + 1;
			end
			Lp := Lp - BPW;
			y[SVALUE] := Lp;
			! checklocal(y);
		end
		if (Tk \= COMMA) leave;
		Tk := scan();
	end
	xsemi();
end

constdecl(glb) do var y;
	Tk := scan();
	while (1) do
		xsymbol();
		y := add(Str, glb|CNST, 0);
		Tk := scan();
		xeqsign();
		y[SVALUE] := constval();
		if (Tk \= COMMA) leave;
		Tk := scan();
	end
	xsemi();
end

stcdecl(glb) do var y, i;
	Tk := scan();
	xsymbol();
	y := add(Str, glb|CNST, 0);
	Tk := scan();
	xeqsign();
	i := 0;
	while (1) do
		xsymbol();
		add(Str, glb|CNST, i);
		i := i+1;
		Tk := scan();
		if (Tk \= COMMA) leave;
		Tk := scan();
	end
	y[SVALUE] := i;
	xsemi();
end

fwddecl() do var y, n, l1, l2;
	Tk := scan();
	l1 := newlab();
	gen(CG_JUMP, findlab(l1));
	while (1) do
		xsymbol();
		l2 := newlab();
		commit();
		addfwd(l2, Tp);
		y := add(Str, GLOB|FORW, Tp);
		gen(CG_JUMP, findlab(l2));
		Tk := scan();
		xlparen();
		n := constval();
		if (n < 0) aw("invalid arity", 0);
		y[SFLAGS] := y[SFLAGS] | (n << 8);
		xrparen();
		if (Tk \= COMMA) leave;
		Tk := scan();
	end
	resolve(l1);
	xsemi();
end

decl    stmt(1);

fundecl() do
	var     l_base, l_addr;
	var     i, na, oyp, onp;
	var     y, l;

	if (Verbose) do
		writes(Str);
		nl();
	end
	l_addr := 2*BPW;
	na := 0;
	l := newlab();
	gen(CG_JUMP, findlab(l));
	commit();
	y := add(Str, GLOB|FUNC, Tp);
	Tk := scan();
	oyp := Yp;
	onp := Np;
	l_base := Yp;
	xlparen();
	while (Tk = SYMBOL) do
		add(Str, 0, l_addr);
		l_addr := l_addr + BPW;
		na := na+1;
		Tk := scan();
		if (Tk \= COMMA) leave;
		Tk := scan();
	end
	xrparen();
	Rettype := KEND;
	if (Tk = KFAR) do
	    y[SFLAGS] := y[SFLAGS] | FUNCF;
	    Rettype := KFAR;
	    Tk := scan();
	end
	if (Tk = KFINT) do
	    y[SFLAGS] := y[SFLAGS] | FUNCI;
	    Rettype := KFINT;
	    Tk := scan();
	end
	for (i = l_base, Yp, SYM) do
	    ie (Rettype = KFAR)
		Syms[i+SVALUE] := 8+na*BPW - Syms[i+SVALUE];
	    else ie (Rettype = KFINT)
		Syms[i+SVALUE] := 2 - Syms[i+SVALUE];
	    else
		Syms[i+SVALUE] := 6+na*BPW - Syms[i+SVALUE];
	end
	if (y[SFLAGS] & FORW) do
		if (na \= y[SFLAGS] >> 8)
			aw("function does not match DECL", y[SNAME]);
		y[SFLAGS] := y[SFLAGS] & ~FORW | FUNC;
		resolve_fwd(y[SVALUE]);
		y[SVALUE] := Tp;
	end
	y[SFLAGS] := y[SFLAGS] | (na << 8);
	if (na) gen(CG_MKFRAME, 0);
	Frame := na;
	Retlab := newlab();
	if (Rettype = KFINT) do
	    gen(CG_PUSHA, 0);
	    Lp := Lp - 20;
	end
	stmt(1);
	ie (Rettype = KFAR) do
	    if (Retlab) resolve(Retlab);
	    Retlab := 0;
	    if (Frame) gen(CG_DELFRAME, 0);
	    Frame := 0;
	    gen(CG_RETF, 0);
	end
	else ie (Rettype = KFINT) do
	    if (Retlab) resolve(Retlab);
	    Retlab := 0;
	    if (Frame) do
		gen(CG_POPA, 0);
		gen(CG_DELFRAME, 0);
	    end
	    Frame := 0;
	    gen(CG_IRET, 0);
	end
	else do
	    if (Retlab) resolve(Retlab);
	    Retlab := 0;
	    if (Frame) gen(CG_DELFRAME, 0);
	    Frame := 0;
	    gen(CG_RET, 0);
	end
	resolve(l);
	Yp := oyp;
	Np := onp;
	Lp := 0;
end

declaration(glb)
	ie (Tk = KVAR)
		vardecl(glb);
	else ie (Tk = KCONST)
		constdecl(glb);
	else ie (Tk = KSTRUCT)
		stcdecl(glb);
	else ie (Tk = KDECL)
		fwddecl();
	else
		fundecl();

decl    expr(1);

load(y) ie (y[SFLAGS] & GLOB)
		gen(CG_LDGLOB, y[SVALUE]);
	else
		gen(CG_LDLOCL, y[SVALUE]);

store(y)
	ie (y[SFLAGS] & GLOB)
		gen(CG_STGLOB, y[SVALUE]);
	else
		gen(CG_STLOCL, y[SVALUE]);

fncall(fn, ind) do var i , msg;
	msg := "call of non-function";
	Tk := scan();
	if (fn = 0) aw(msg, 0);
	if (\ind /\ fn[SFLAGS] & (FUNC|FORW) = 0) aw(msg, fn[SNAME]);
	i := 0;
	while (Tk \= RPAREN) do
		expr(0);
		i := i+1;
		if (Tk \= COMMA) leave;
		Tk := scan();
		if (Tk = RPAREN)
			aw("syntax error", Str);
	end
	if (\ind /\ i \= fn[SFLAGS] >> 8)
		aw("wrong number of arguments", fn[SNAME]);
	expect(RPAREN, "')'");
	if (fn[SFLAGS] & (FUNCI))
		aw("wrong function type", fn[SNAME]);
	Tk := scan();
	if (active()) spill();
	ie (ind = 2) do
	    if (fn[SFLAGS] & FUNC)
		aw("wrong variable type", fn[SNAME]);
	    load(fn);
	    gen(CG_CALRF, 0);
	end 
	else do 
	    if (fn[SFLAGS] & FUNCF)
		aw("wrong function type", fn[SNAME]);
	    ie (fn[SFLAGS] & (FUNC|FORW))
		    gen(CG_CALL, fn[SVALUE]);
	    else do
		    load(fn);
		    gen(CG_CALR, 0);
	    end
	end
	if (i \= 0) gen(CG_UNSTACK, i*BPW);
	activate();
end

mkstring(s) do var i, a, k, l;
	k := str_length(s);
	l := newlab();
	gen(CG_JUMP, findlab(l));
	commit();
	a := Tp;
	for (i=0, k+1) emit(s::i);
	resolve(l);
	return a;
end

mkbytevec() do var a, l, k;
	Tk := scan();
	expect(LBRACK, "'['");
	Tk := scan();
	l := newlab();
	gen(CG_JUMP, findlab(l));
	commit();
	a := Tp;
	while (1) do
		k := constval();
		if (k > 255 \/ k < 0)
			aw("byte vector member out of range", Str);
		emit(k);
		if (Tk \= COMMA) leave;
		Tk := scan();
	end
	expect(RBRACK, "']'");
	Tk := scan();
	resolve(l);
	return a;
end

var     gtbl[MAXTBL*3], gaf[MAXTBL*3];

mktable2(depth) do
	var     n, i, a, l, y;
	var     tbl, af;
	var     dynamic;

	if (depth > 2) aw("table nesting too deep", 0);
	tbl := @gtbl[depth*128];
	af := @gaf[depth*128];
	Tk := scan();
	dynamic := 0;
	n := 0;
	while (Tk \= RBRACK) do
		if (n >= MAXTBL)
			aw("table too big", 0);
		ie (Tk = LPAREN /\ \dynamic) do
			Tk := scan();
			dynamic := 1;
			loop;
		end
		else ie (dynamic) do
			expr(1);
			l := newlab();
			gen(CG_STGLOB, findlab(l));
			tbl[n] := 0;
			af[n] := l;
			if (Tk = RPAREN) do
				Tk := scan();
				dynamic := 0;
			end
		end
		else ie (Tk = INTEGER \/ Tk = SYMBOL) do
			tbl[n] := constval();
			af[n] := 0;
		end
		else ie (Tk = STRING) do
			tbl[n] := mkstring(Str);
			af[n] := 0;
			Tk := scan();
		end
		else ie (Tk = LBRACK) do
			tbl[n] := mktable2(depth+1);
			af[n] := 0;
		end
		else ie (Tk = KPACKED) do
			tbl[n] := mkbytevec();
			af[n] := 0;
		end
		else ie (Tk = ADDROF) do
			Tk := scan();
			xsymbol();
			y := lookup(Str, FUNC);
			tbl[n] := y[SVALUE];
			af[n] := 0;
			Tk := scan();
		end
		else do
			aw("invalid table element", Str);
		end
		n := n+1;
		if (Tk \= COMMA) leave;
		Tk := scan();
		if (Tk = RBRACK)
			aw("syntax error", Str);
	end
	if (dynamic)
		aw("missing ')' in dynamic table", 0);
	expect(RBRACK, "']'");
	if (n = 0) aw("empty table", 0);
	Tk := scan();
	l := newlab();
	gen(CG_JUMP, findlab(l));
	commit();
	a := Tp;
	for (i=0, n) do
		if (af[i]) resolve(af[i]);
		emitw(tbl[i]);
	end
	resolve(l);
	return a;
end

mktable() return mktable2(0);

decl    factor(0);

address(lv, bp) do var y;
	y := lookup(Str, 0);
	Tk := scan();
	ie (y[SFLAGS] & CNST) do
		if (lv > 0) aw("invalid location", y[SNAME]);
		spill();
		gen(CG_LDVAL, y[SVALUE]);
	end
	else ie (y[SFLAGS] & (FUNC|FORW)) do
		! Don't load
	end
	else if (lv = 0 \/ Tk = LBRACK \/ Tk = BYTEOP) do
		spill();
		load(y);
	end
	if (Tk = LBRACK \/ Tk = BYTEOP)
		if (y[SFLAGS] & (FUNC|FORW|CNST))
			aw("bad subscript", y[SNAME]);
	while (Tk = LBRACK) do
		Tk := scan();
		bp[0] := 0;
		expr(0);
		expect(RBRACK, "']'");
		Tk := scan();
		y := 0;
		gen(CG_INDEX, 0);
		if (lv = 0 \/ Tk = LBRACK  \/ Tk = BYTEOP)
			gen(CG_DEREF, 0);
	end
	if (Tk = BYTEOP) do
		Tk := scan();
		bp[0] := 1;
		factor();
		y := 0;
		gen(CG_INDXB, 0);
		if (lv = 0) gen(CG_DREFB, 0);
	end
	return y;
end

factor() do var y, op, b;
	ie (Tk = INTEGER) do
		spill();
		gen(CG_LDVAL, Val);
		Tk := scan();
	end
	else ie (Tk = SYMBOL) do
		y := address(0, @b);
		if (Tk = LPAREN) fncall(y, 0);
	end
	else ie (Tk = STRING) do
		spill();
		gen(CG_LDADDR, mkstring(Str));
		Tk := scan();
	end
	else ie (Tk = LBRACK) do
		spill();
		gen(CG_LDADDR, mktable());
	end
	else ie (Tk = KPACKED) do
		spill();
		gen(CG_LDADDR, mkbytevec());
	end
	else ie (Tk = ADDROF) do
		Tk := scan();
		y := address(2, @b);
		ie (y = 0) do
			;
		end
		else ie (y[SFLAGS] & GLOB) do
			spill();
			gen(CG_LDADDR, y[SVALUE]);
		end
		else do
			spill();
			gen(CG_LDLREF, y[SVALUE]);
		end
	end
	else ie (Tk = BINOP) do
		if (Oid \= Minus_op)
			aw("syntax error", Str);
		Tk := scan();
		factor();
		gen(CG_NEG, 0);
	end
	else ie (Tk = UNOP) do
		op := Oid;
		Tk := scan();
		factor();
		gen(Ops[op][OCODE], 0);
	end
	else ie (Tk = LPAREN) do
		Tk := scan();
		expr(0);
		xrparen();
	end
	else ie (Tk = KCALL) do
		Tk := scan();
		xsymbol();
		y := lookup(Str, 0);
		Tk := scan();
		if (Tk \= LPAREN) aw("incomplete CALL", 0);
		fncall(y, 1);
	end
	else ie (Tk = KCALLFAR) do
		Tk := scan();
		xsymbol();
		y := lookup(Str, 0);
		Tk := scan();
		if (Tk \= LPAREN) aw("incomplete CALLFAR", 0);
		fncall(y, 2);
	end
	else do
		aw("syntax error", Str);
	end
end

emitop(stk, p) do
	gen(Ops[stk[p-1]][OCODE], 0);
	return p-1;
end

arith() do var stk[10], p;
	factor();
	p := 0;
	while (Tk = BINOP) do
		while (p /\ Ops[Oid][OPREC] <= Ops[stk[p-1]][OPREC])
			p := emitop(stk, p);
		stk[p] := Oid;
		p := p+1;
		Tk := scan();
		factor();
	end
	while (p > 0)
		p := emitop(stk, p);
end

logop(conop) do var l;
	ie (conop)
		arith();
	else
		logop(%1);
	l := 0;
	while (Tk = (conop-> CONJ: DISJ)) do
		Tk := scan();
		if (\l) l := newlab();
		commit();
		gen(conop-> CG_JMPFALSE: CG_JMPTRUE, findlab(l));
		clear();
		ie (conop)
			arith();
		else
			logop(%1);
	end
	if (l) resolve(l);
end

expr(clr) do var l1, l2;
	if (clr) clear();
	logop(0);
	if (Tk = COND) do
		Tk := scan();
		l1 := newlab();
		l2 := newlab();
		gen(CG_JMPFALSE, findlab(l1));
		expr(1);
		expect(COLON, "':'");
		Tk := scan();
		gen(CG_JUMP, findlab(l2));
		resolve(l1);
		expr(1);
		resolve(l2);
	end
end

halt_stmt() do var r;
	Tk := scan();
	r := Tk = SEMI-> 0: constval();
	gen(CG_HALT, r);
	xsemi();
end

return_stmt() do
	Tk := scan();
	if (Retlab = 0)
		aw("cannot return from main body", 0);
	ie (Tk = SEMI)
		gen(CG_CLEAR, 0);
	else
		expr(1);
	ie (Frame /\ Lp /\ Lp0 = Lp) do
		gen(CG_JUMP, findlab(Retlab));
	end
	else do
		if (Lp \= 0) gen(CG_UNSTACK, -Lp);
		ie (Rettype = KFAR) do
		    if (Frame) gen(CG_DELFRAME, 0);
		    gen(CG_RETF, 0);
		end
		else ie (Rettype = KFINT) do
		    if (Frame) do
			gen(CG_POPA, 0);
			gen(CG_DELFRAME, 0);
		    end
		    gen(CG_IRET, 0);
		end
		else do
		    if (Frame) gen(CG_DELFRAME, 0);
		    gen(CG_RET, 0);
		end
	end
	xsemi();
end

if_stmt(alt) do var l1, l2;
	Tk := scan();
	xlparen();
	expr(1);
	l1 := newlab();
	gen(CG_JMPFALSE, findlab(l1));
	xrparen();
	stmt(0);
	if (alt) do
		l2 := newlab();
		gen(CG_JUMP, findlab(l2));
		resolve(l1);
		l1 := l2;
		expect(KELSE, "ELSE");
		Tk := scan();
		stmt(0);
	end
	resolve(l1);
end

while_stmt() do var olp, olv, l, a0;
	Tk := scan();
	commit();
	olp := Loop0;
	olv := Lvp;
	a0 := Tp;
	Loop0 := Tp;
	xlparen();
	expr(1);
	xrparen();
	l := newlab();
	gen(CG_JMPFALSE, findlab(l));
	stmt(0);
	gen(CG_JUMP, a0);
	resolve(l);
	while (Lvp > olv) do
		resolve(Leaves[Lvp-1]);
		Lvp := Lvp-1;
	end
	Loop0 := olp;
end

for_stmt() do
	var     y, l, a0;
	var     step;
	var     oll, olp, olv;
	var     test;

	Tk := scan();
	oll := Llp;
	olv := Lvp;
	olp := Loop0;
	Loop0 := 0;
	xlparen();
	xsymbol();
	y := lookup(Str, 0);
	if (y[SFLAGS] & (CNST|FUNC|FORW))
		aw("unexpected type", y[SNAME]);
	Tk := scan();
	xeqsign();
	expr(1);
	store(y);
	expect(COMMA, "','");
	Tk := scan();
	commit();
	a0 := Tp;
	test := Tp;
	load(y);
	expr(0);
	ie (Tk = COMMA) do
		Tk := scan();
		step := constval();
	end
	else do
		step := 1;
	end
	l := newlab();
	gen(step<0-> CG_FORDOWN: CG_FOR, findlab(l));
	xrparen();
	stmt(0);
	while (Llp > oll) do
		resolve(Loops[Llp-1]);
		Llp := Llp-1;
	end
	ie (y[SFLAGS] & GLOB) do
		ie (step = 1) do
			gen(CG_INCGLOB, y[SVALUE]);
		end
		else do
			gen(CG_LDGLOB, y[SVALUE]);
			gen(CG_INCR, step);
			gen(CG_STGLOB, y[SVALUE]);
		end
	end
	else do
		ie (step = 1) do
			gen(CG_INCLOCL, y[SVALUE]);
		end
		else do
			gen(CG_LDLOCL, y[SVALUE]);
			gen(CG_INCR, step);
			gen(CG_STLOCL, y[SVALUE]);
		end
	end
	gen(CG_JUMP, a0);
	resolve(l);
	while (Lvp > olv) do
		resolve(Leaves[Lvp-1]);
		Lvp := Lvp-1;
	end
	Loop0 := olp;
end

leave_stmt() do var l;
	Tk := scan();
	if (Loop0 < 0)
		aw("LEAVE not in loop context", 0);
	xsemi();
	if (Lvp >= MAXLOOP)
		aw("too many LEAVEs", 0);
	l := newlab();
	Leaves[Lvp] := l;
	if (Lbp0 \= Lp) gen(CG_UNSTACK, Lbp0-Lp);
	gen(CG_JUMP, findlab(l));
	Lvp := Lvp+1;
end

loop_stmt() do var l;
	Tk := scan();
	if (Loop0 < 0)
		aw("LOOP not in loop context", 0);
	xsemi();
	ie (Loop0 > 0) do
		gen(CG_JUMP, Loop0);
	end
	else do
		if (Llp >= MAXLOOP)
			aw("too many LOOPs", 0);
		l := newlab();
		Loops[Llp] := l;
		if (Lbp0 \= Lp) gen(CG_UNSTACK, Lbp0-Lp);
		gen(CG_JUMP, findlab(l));
		Llp := Llp+1;
	end
end

asg_or_call() do var y, b;
	clear();
	y := address(1, @b);
	ie (Tk = LPAREN) do
		fncall(y, 0);
	end
	else ie (Tk = ASSIGN) do
		Tk := scan();
		expr(0);
		ie (y = 0)
			gen(b-> CG_STINDB: CG_STINDR, 0);
		else ie (y[SFLAGS] & (FUNC|FORW|CNST|VECT))
			aw("bad location", y[SNAME]);
		else
			store(y);
	end
	else do
		aw("syntax error", Str);
	end
	xsemi();
end

decl    compound(2);

stmt(body) ie (Tk = KFOR)
		for_stmt();
	else ie (Tk = KHALT)
		halt_stmt();
	else ie (Tk = KIE)
		if_stmt(1);
	else ie (Tk = KIF)
		if_stmt(0);
	else ie (Tk = KELSE)
		aw("ELSE without IE", 0);
	else ie (Tk = KLEAVE)
		leave_stmt();
	else ie (Tk = KLOOP)
		loop_stmt();
	else ie (Tk = KRETURN)
		return_stmt();
	else ie (Tk = KWHILE)
		while_stmt();
	else ie (Tk = KDO)
		compound(body, 0);
	else ie (Tk = SYMBOL)
		asg_or_call();
	else ie (Tk = KCALL) do
		clear();
		factor();
	end
	else ie (Tk = KCALLFAR) do
		clear();
		factor();
	end
	else ie (Tk = SEMI)
		Tk := scan();
	else
		expect(%1, "statement");

compound(body, main) do var oyp, olp, olbp, onp, ols, msg;
	msg := "unexpected end of compound statement";
	Tk := scan();
	oyp := Yp;
	onp := Np;
	olp := Lp;
	ols := Ls;
	olbp := Lbp0;
	Ls := 0;
	Lbp0 := Lp;
	while (Tk = KVAR \/ Tk = KCONST \/ Tk = KSTRUCT) do
		if (Tk = KVAR /\ \Frame) do
			gen(CG_MKFRAME, 0);
			Frame := 1;
		end
		declaration(0);
	end
	if (Ls) gen(CG_STACK, -(Ls*BPW));
	if (body) Lp0 := Lp;
	if (main) Lbp0 := Lp;
	while (Tk \= KEND) do
		if (Tk = ENDFILE) aw(msg, 0);
		stmt(0);
	end
	Tk := scan();
	if (body) do
		gen(CG_CLEAR, 0);
		resolve(Retlab);
		Retlab := 0;
	end
	if (olp \= Lp) gen(CG_UNSTACK, olp-Lp);
	if (body /\ Frame) do
		if (Rettype = KFINT) gen(CG_POPA, 0);
		gen(CG_DELFRAME, 0);
		Frame := 0;
	end
	Yp := oyp;
	Np := onp;
	Lp := olp;
	Ls := ols;
	Lbp0 := olbp;
end

checkclass()
	if (\str_equal(Str, "t3x"))
		aw("class name must be T3X", Str);

module_decl() do
	Tk := scan();
	xsymbol();
	Tk := scan();
	xlparen();
	xsymbol();
	checkclass();
	Tk := scan();
	xrparen();
	xsemi();
end

object_decl() do
	Tk := scan();
	xsymbol();
	if (\str_equal(Str, "t"))
		aw("object name must be T", Str);
	Tk := scan();
	expect(LBRACK, "'['");
	Tk := scan();
	expect(SYMBOL, "symbol");
	checkclass();
	Tk := scan();
	expect(RBRACK, "']'");
	Tk := scan();
	xsemi();
end

program() do var i;
	Tk := scan();
	if (Tk = KMODULE) module_decl();
	if (Tk = KOBJECT) object_decl();
	while ( Tk = KVAR \/ Tk = KCONST \/ Tk = SYMBOL \/
		Tk = KDECL \/ Tk = KSTRUCT
	)
		declaration(GLOB);
	if (Tk \= KDO)
		aw("DO or declaration expected", 0);
	compound(0, 1);
	if (Tk \= ENDFILE)
		aw("trailing characters", Str);
	gen(CG_HALT, 0);
	for (i=0, Yp, SYM)
		if (Syms[i+SFLAGS] & FORW /\ Syms[i+SVALUE])
			aw("undefined function", Syms[i+SNAME]);
end

!
! Main
!

emitlib() do var i, j, k, lib;
	lib :=
	!LIBRARY!
	[ 0x0080,
	  packed [ 
	    0xe9,0x52,0x05,0x5a,0x06,0x54,0x33,0x58,0xe9,0x96,0x00,0xe9,
	    0xf2,0x01,0xe9,0x2a,0x02,0xe9,0x70,0x02,0xe9,0xc3,0x02,0xe9,
	    0xfe,0x02,0xe9,0x1f,0x03,0xe9,0x7f,0x03,0xe9,0xe5,0x03,0xe9,
	    0xf8,0x03,0xe9,0x0d,0x04,0xe9,0x6e,0x04,0xe9,0x84,0x04,0xe9,
	    0x97,0x04,0xe9,0xa2,0x04,0xe9,0xad,0x04,0xe9,0xb8,0x04,0xe9,
	    0xc3,0x04,0xe9,0xce,0x04,0xe9,0x0a,0x04,0xe9,0xd6,0x04,0xe9,
	    0xe1,0x04,0xe9,0xec,0x04,0xe9,0xf7,0x04,0xe9,0xc2,0x01,0xe9,
	    0x0f,0x02,0xe9,0x4d,0x02,0xe9,0x91,0x02,0xe9,0x4b,0x01,0xe9,
	    0x5b,0x01,0xe9,0x6e,0x01,0xe9,0x7c,0x01,0xe9,0x8f,0x01,0xe9,
	    0x10,0x01,0xe9,0x19,0x01,0xe9,0x21,0x01,0xe9,0x2a,0x01,0xe9,
	    0x8a,0x00,0xe9,0xb3,0x00,0xe9,0xd2,0x00 ],
	  0x0080,
	  packed [ 
	    0xe9,0x57,0x00,0xe9,0x69,0x00,0xe9,0x71,0x00,0xe9,0x71,0x01,
	    0xe9,0x23,0x00,0xe9,0x23,0x00,0xe9,0x2a,0x00,0xe9,0x10,0x00,
	    0xe9,0x14,0x00,0xe9,0x07,0x00,0xe9,0x1f,0x02,0xb8,0x02,0x00,
	    0xc3,0x87,0xdb,0xc3,0x89,0xe0,0x81,0xc0,0x02,0x00,0xc3,0x58,
	    0x50,0xc3,0x9c,0x58,0xc3,0x55,0x89,0xe5,0x8b,0x46,0x04,0x50,
	    0x9d,0x5d,0xc3,0x55,0x89,0xe5,0x1e,0x06,0x8b,0x46,0x08,0x8b,
	    0x5e,0x06,0x8b,0x4e,0x04,0xfa,0x8e,0xd0,0x8e,0xd8,0x8e,0xc0,
	    0x89,0xdc,0x50,0x51,0xfb,0xcb,0x55,0x89,0xe5,0x8b,0x76,0x08,
	    0x8b,0x46,0x04,0x89,0x04,0x8b,0x46,0x06,0x89,0x44,0x02,0x31,
	    0xc0,0x5d,0xc3,0x55,0x89,0xe5,0x8b,0x76,0x04,0x8b,0x44,0x02,
	    0x5d,0xc3,0x55,0x89,0xe5,0x8b,0x76,0x04 ],
	  0x0080,
	  packed [ 
	    0x8b,0x04,0x5d,0xc3,0x55,0x89,0xe5,0x8b,0x46,0x10,0xbe,0x23,
	    0x02,0x2e,0x88,0x04,0x8b,0x46,0x0e,0x8b,0x5e,0x0c,0x8b,0x4e,
	    0x0a,0x8b,0x56,0x08,0x8b,0x76,0x06,0x8b,0x7e,0x04,0xcd,0x00,
	    0x72,0x05,0x31,0xc0,0xe9,0x03,0x00,0xb8,0x01,0x00,0x5d,0xc3,
	    0x55,0x89,0xe5,0x8b,0x46,0x10,0xbe,0x4f,0x02,0x2e,0x88,0x04,
	    0x8b,0x46,0x0e,0x8b,0x5e,0x0c,0x8b,0x4e,0x0a,0x8b,0x56,0x08,
	    0x8b,0x76,0x06,0x8b,0x7e,0x04,0xcd,0x00,0x5d,0xc3,0x55,0x89,
	    0xe5,0x8b,0x46,0x10,0xbe,0x71,0x02,0x2e,0x88,0x04,0x8b,0x46,
	    0x0e,0x8b,0x5e,0x0c,0x8b,0x4e,0x0a,0x8b,0x56,0x08,0x8b,0x76,
	    0x06,0x8b,0x7e,0x04,0xcd,0x00,0x74,0x05,0x31,0xc0,0xe9,0x03,
	    0x00,0xb8,0x01,0x00,0x5d,0xc3,0x55,0x89 ],
	  0x0080,
	  packed [ 
	    0xe5,0x8b,0x56,0x06,0x8a,0x46,0x04,0xee,0x5d,0xc3,0x55,0x89,
	    0xe5,0x8b,0x56,0x04,0x31,0xc0,0xec,0x5d,0xc3,0x55,0x89,0xe5,
	    0x8b,0x56,0x06,0x8b,0x46,0x04,0xef,0x5d,0xc3,0x55,0x89,0xe5,
	    0x8b,0x56,0x04,0xed,0x5d,0xc3,0x55,0x89,0xe5,0x1e,0x8b,0x46,
	    0x06,0x8e,0xd8,0x8b,0x5e,0x04,0x31,0xc0,0x8a,0x07,0x1f,0x5d,
	    0xc3,0x55,0x89,0xe5,0x1e,0x8b,0x46,0x08,0x8e,0xd8,0x8b,0x5e,
	    0x06,0x8a,0x46,0x04,0x88,0x07,0x31,0xc0,0x1f,0x5d,0xc3,0x55,
	    0x89,0xe5,0x1e,0x8b,0x46,0x06,0x8e,0xd8,0x8b,0x5e,0x04,0x8b,
	    0x07,0x1f,0x5d,0xc3,0x55,0x89,0xe5,0x1e,0x8b,0x46,0x08,0x8e,
	    0xd8,0x8b,0x5e,0x06,0x8b,0x46,0x04,0x89,0x07,0x31,0xc0,0x1f,
	    0x5d,0xc3,0x8c,0xc8,0xc3,0x8c,0xd0,0xc3 ],
	  0x0080,
	  packed [ 
	    0x55,0x89,0xe5,0x8b,0x7e,0x04,0xfc,0xb0,0x0d,0xaa,0xb0,0x0a,
	    0xaa,0x30,0xc0,0xaa,0x8b,0x46,0x04,0x5d,0xc3,0x55,0x89,0xe5,
	    0x1e,0x06,0x8b,0x46,0x0c,0x8e,0xd8,0x8b,0x46,0x0a,0x50,0x8b,
	    0x46,0x08,0x8e,0xc0,0x8b,0x46,0x06,0x50,0x8b,0x46,0x04,0x50,
	    0xe8,0x08,0x00,0x81,0xc4,0x06,0x00,0x07,0x1f,0x5d,0xc3,0x55,
	    0x89,0xe5,0x8b,0x7e,0x08,0x8b,0x76,0x06,0x8b,0x4e,0x04,0x39,
	    0xfe,0x75,0x04,0x31,0xc0,0xeb,0x14,0xff,0xc1,0xfc,0xf3,0xa6,
	    0x09,0xc9,0x75,0x04,0x31,0xc0,0xeb,0x07,0x8a,0x45,0xff,0x2a,
	    0x44,0xff,0x98,0x5d,0xc3,0x55,0x89,0xe5,0x1e,0x06,0x8b,0x46,
	    0x0c,0x8e,0xc0,0x8b,0x7e,0x0a,0x8b,0x46,0x08,0x8e,0xd8,0x8b,
	    0x76,0x06,0x8b,0x4e,0x04,0xfc,0xf3,0xa4 ],
	  0x0080,
	  packed [ 
	    0x07,0x1f,0x5d,0xc3,0x55,0x89,0xe5,0x8b,0x7e,0x08,0x8b,0x76,
	    0x06,0x8b,0x4e,0x04,0xfc,0x39,0xf7,0x74,0x0d,0x72,0x09,0xfd,
	    0x01,0xce,0x01,0xcf,0xff,0xce,0xff,0xcf,0xf3,0xa4,0x5d,0x31,
	    0xc0,0xc3,0x55,0x89,0xe5,0x06,0x8b,0x46,0x0a,0x8e,0xc0,0x8b,
	    0x7e,0x08,0x8b,0x46,0x06,0x8b,0x4e,0x04,0xfc,0xf3,0xaa,0x07,
	    0x5d,0x31,0xc0,0xc3,0x55,0x89,0xe5,0x06,0x8b,0x46,0x0a,0x8e,
	    0xc0,0x8b,0x7e,0x08,0x8b,0x46,0x06,0x8b,0x4e,0x04,0xfc,0xf3,
	    0xab,0x07,0x5d,0x31,0xc0,0xc3,0x55,0x89,0xe5,0x8b,0x7e,0x08,
	    0x8b,0x46,0x06,0x8b,0x4e,0x04,0xfc,0xf3,0xaa,0x5d,0x31,0xc0,
	    0xc3,0x55,0x89,0xe5,0x1e,0x8b,0x46,0x0a,0x8e,0xd8,0x8b,0x7e,
	    0x08,0x89,0xfa,0x8b,0x46,0x06,0x8b,0x4e ],
	  0x0080,
	  packed [ 
	    0x04,0xff,0xc1,0xfc,0xf2,0xae,0x09,0xc9,0x74,0x08,0x89,0xf8,
	    0x29,0xd0,0xff,0xc8,0xeb,0x03,0xb8,0xff,0xff,0x1f,0x5d,0xc3,
	    0x55,0x89,0xe5,0x8b,0x7e,0x08,0x89,0xfa,0x8b,0x46,0x06,0x8b,
	    0x4e,0x04,0xff,0xc1,0xfc,0xf2,0xae,0x09,0xc9,0x74,0x08,0x89,
	    0xf8,0x29,0xd0,0xff,0xc8,0xeb,0x03,0xb8,0xff,0xff,0x5d,0xc3,
	    0x55,0x89,0xe5,0x8b,0x4e,0x08,0xff,0xc9,0xbe,0x82,0x00,0xfc,
	    0xff,0xce,0xac,0x80,0xf8,0x20,0x74,0xfa,0x80,0xf8,0x09,0x74,
	    0xf5,0x80,0xf8,0x0d,0x75,0x05,0xb8,0xff,0xff,0xeb,0x3e,0x09,
	    0xc9,0x74,0x14,0xff,0xc9,0xac,0x80,0xf8,0x20,0x74,0xdd,0x80,
	    0xf8,0x09,0x74,0xd8,0x80,0xf8,0x0d,0x74,0xd3,0xeb,0xee,0x8b,
	    0x7e,0x06,0x8b,0x4e,0x04,0x31,0xdb,0xff ],
	  0x0080,
	  packed [ 
	    0xc3,0x39,0xcb,0x73,0x13,0xaa,0xac,0x80,0xf8,0x20,0x74,0x0c,
	    0x80,0xf8,0x09,0x74,0x07,0x80,0xf8,0x0d,0x74,0x02,0xeb,0xe7,
	    0x31,0xc0,0xaa,0x89,0xd8,0x5d,0xc3,0x55,0x89,0xe5,0x8b,0x46,
	    0x04,0x81,0xf8,0x01,0x00,0x75,0x11,0xb8,0x00,0x3c,0x8b,0x56,
	    0x06,0x31,0xc9,0xcd,0x21,0x73,0x29,0xb8,0xff,0xff,0xeb,0x4a,
	    0x81,0xf8,0x00,0x00,0x74,0x0e,0x81,0xf8,0x03,0x00,0x74,0x05,
	    0xb8,0xff,0xff,0xeb,0x39,0xb8,0x02,0x00,0x81,0xc8,0x00,0x3d,
	    0x8b,0x56,0x06,0xcd,0x21,0x73,0x05,0xb8,0xff,0xff,0xeb,0x26,
	    0x81,0xf8,0x00,0x00,0x7d,0x05,0xb8,0xff,0xff,0xeb,0x1b,0x8b,
	    0x5e,0x04,0x81,0xfb,0x03,0x00,0x75,0x12,0x50,0x89,0xc3,0xb8,
	    0x02,0x42,0x31,0xc9,0x31,0xd2,0xcd,0x21 ],
	  0x0080,
	  packed [ 
	    0x58,0x73,0x03,0xb8,0xff,0xff,0x5d,0xc3,0x55,0x89,0xe5,0x8b,
	    0x5e,0x04,0xb8,0x00,0x3e,0xcd,0x21,0x73,0x05,0xb8,0xff,0xff,
	    0xeb,0x02,0x31,0xc0,0x5d,0xc3,0x55,0x89,0xe5,0xb8,0x00,0x3f,
	    0x8b,0x5e,0x08,0x8b,0x56,0x06,0x8b,0x4e,0x04,0xcd,0x21,0x73,
	    0x03,0xb8,0xff,0xff,0x5d,0xc3,0x55,0x89,0xe5,0xb8,0x00,0x40,
	    0x8b,0x5e,0x08,0x8b,0x56,0x06,0x8b,0x4e,0x04,0xcd,0x21,0x73,
	    0x03,0xb8,0xff,0xff,0x5d,0xc3,0x55,0x89,0xe5,0x8b,0x56,0x06,
	    0x31,0xc9,0x8b,0x46,0x04,0x09,0xc0,0x75,0x05,0xb8,0x00,0x42,
	    0xeb,0x28,0x81,0xf8,0x01,0x00,0x75,0x06,0xb8,0x01,0x42,0xe9,
	    0x1c,0x00,0x81,0xf8,0x02,0x00,0x75,0x09,0xb8,0x02,0x42,0xf7,
	    0xda,0xff,0xc9,0xeb,0x0d,0x81,0xf8,0x03 ],
	  0x0080,
	  packed [ 
	    0x00,0x75,0x12,0xb8,0x01,0x42,0xf7,0xda,0xff,0xc9,0x8b,0x5e,
	    0x08,0xcd,0x21,0x72,0x04,0x31,0xc0,0xeb,0x03,0xb8,0xff,0xff,
	    0x5d,0xc3,0x55,0x89,0xe5,0xb8,0x00,0x56,0x8b,0x56,0x06,0x8b,
	    0x7e,0x04,0xcd,0x21,0x73,0x05,0xb8,0xff,0xff,0xeb,0x02,0x31,
	    0xc0,0x5d,0xc3,0x55,0x89,0xe5,0xb8,0x00,0x41,0x8b,0x56,0x04,
	    0xcd,0x21,0x73,0x05,0xb8,0xff,0xff,0xeb,0x02,0x31,0xc0,0x5d,
	    0xc3,0x5e,0x5b,0x31,0xd2,0x39,0xc3,0x75,0x02,0xff,0xca,0x89,
	    0xd0,0xff,0xe6,0x5e,0x5b,0x31,0xd2,0x39,0xc3,0x74,0x02,0xff,
	    0xca,0x89,0xd0,0xff,0xe6,0x5e,0x5b,0x31,0xd2,0x39,0xc3,0x7d,
	    0x02,0xff,0xca,0x89,0xd0,0xff,0xe6,0x5e,0x5b,0x31,0xd2,0x39,
	    0xc3,0x7e,0x02,0xff,0xca,0x89,0xd0,0xff ],
	  0x005a,
	  packed [ 
	    0xe6,0x5e,0x5b,0x31,0xd2,0x39,0xc3,0x7f,0x02,0xff,0xca,0x89,
	    0xd0,0xff,0xe6,0x5e,0x5b,0x31,0xd2,0x39,0xc3,0x7c,0x02,0xff,
	    0xca,0x89,0xd0,0xff,0xe6,0x5e,0x5b,0x31,0xd2,0x39,0xc3,0x73,
	    0x02,0xff,0xca,0x89,0xd0,0xff,0xe6,0x5e,0x5b,0x31,0xd2,0x39,
	    0xc3,0x76,0x02,0xff,0xca,0x89,0xd0,0xff,0xe6,0x5e,0x5b,0x31,
	    0xd2,0x39,0xc3,0x77,0x02,0xff,0xca,0x89,0xd0,0xff,0xe6,0x5e,
	    0x5b,0x31,0xd2,0x39,0xc3,0x72,0x02,0xff,0xca,0x89,0xd0,0xff,
	    0xe6,0xb8,0xfe,0xff,0x89,0xc4 ],
	  0 ];
	!LIBRARY!
	i := 0;
	while (lib[i]) do
		k := lib[i];
		i := i+1;
		for (j=0, k) emit(lib[i]::j);
		i := i+1;
	end
end

init(p) do var i, b::10;
	Pass := p;
	Rejected := 0;
	Ip := 0;
	Ep := 0;
	Gp := 0;
	Gtop := 0;
	Outp := 0;
	Tp := 0x100;
	Dp := 0;
	Lp := 0;
	Yp := 0;
	Np := 0;
	Fwp := 0;
	Lab := 0;
	Line := 1;
	Acc := 0;
	Retlab := 0;
	Frame := 0;
	Loop0 := %1;
	Lvp := 0;
	Llp := 0;
	Qi := CG_NULL;
	Codetbl := [
		[ CG_NULL,      ""              ],
		[ CG_PUSH,      "50"            ], ! push ax
		[ CG_CLEAR,     "31c0"          ], ! xor ax,ax
		[ CG_DROP,      "5b"            ], ! pop bx
		[ CG_LDVAL,     "b8,w"          ], ! mov ax,W
		[ CG_LDADDR,    "b8,w"          ], ! mov ax,W
		[ CG_LDLREF,    "8d86,w"        ], ! lea ax,[bp+W]
		[ CG_LDGLOB,    "a1,w"          ], ! mov ax,[W]
		[ CG_LDLOCL,    "8b86,w"        ], ! mov ax,[bp+W]
		[ CG_STGLOB,    "a3,w"          ], ! mov [W],ax
		[ CG_STLOCL,    "8986,w"        ], ! mov [bp+W],ax
		[ CG_STINDR,    "5b8907"        ], ! pop bx; mov [bx],ax
		[ CG_STINDB,    "5b8807"        ], ! pop bx; mov [bx],al
		[ CG_INCGLOB,   "ff06,w"        ], ! inc word [W]
		[ CG_INCLOCL,   "ff86,w"        ], ! inc word [bp+W]
		[ CG_INCR,      "05,w"          ], ! add ax,W
		[ CG_STACK,     "81c4,w"        ], ! add sp,W
		[ CG_UNSTACK,   "81c4,w"        ], ! add sp,W
		[ CG_LOCLVEC,   "89e050"        ], ! mov ax,sp; push ax
		[ CG_GLOBVEC,   "8926,w"        ], ! mov [W],sp
		[ CG_INDEX,     "d1e05b01d8"    ], ! shl ax,1;pop bx;add ax,bx
		[ CG_DEREF,     "89c38b07"      ], ! mov bx,ax; mov ax,[bx]
		[ CG_INDXB,     "5b01d8"        ], ! pop bx; add ax,bx
		[ CG_DREFB,     "89c331c08a07"  ], ! mov bx,ax; xor ax,ax
						   ! mov ax,[bx]
		[ CG_CALL,      "e8,r"          ], ! call R
		[ CG_CALR,      "ffd0"          ], ! call ax
		[ CG_CALRF,     "89c3ff1f"      ], ! mov bx,ax; call far [bx]
		[ CG_JUMP,      "e9,r"          ], ! jmp R
		[ CG_RJUMP,     "eb,b"          ], ! jmps R
		[ CG_JMPFALSE,  "09c07503e9,r"  ], ! or ax,ax; jne +3; jmp R
		[ CG_JMPTRUE,   "09c07403e9,r"  ], ! or ax,ax; je +3; jmp R
		[ CG_FOR,       "5b39c37c03e9,r"], ! pop bx; cmp bx,ax; jl +3
						   ! jmp R
		[ CG_FORDOWN,   "5b39c37f03e9,r"], ! pop bx; cmp bx,ax; jg +3
						   ! jmp R
		[ CG_MKFRAME,   "5589e5"        ], ! push bp; mov bp,sp
		[ CG_DELFRAME,  "5d"            ], ! pop bp
		[ CG_RET,       "c3"            ], ! ret
		[ CG_RETF,      "cb"            ], ! retf
		[ CG_IRET,      "cf"            ], ! iret
		[ CG_HALT,      "b8004ccd21"    ], ! mov ax,4c00h; int 21H
		[ CG_NEG,       "f7d8"          ], ! neg ax
		[ CG_INV,       "f7d0"          ], ! not ax
		[ CG_LOGNOT,    "f7d819c0f7d0"  ], ! neg ax; sbb ax,ax; not ax
		[ CG_ADD,       "5b01d8"        ], ! pop bx; add ax,bx
		[ CG_SUB,       "89c35829d8"    ], ! mov bx,ax;pop ax;sub ax,bx
		[ CG_MUL,       "59f7e9"        ], ! pop cx; imul cx
		[ CG_DIV,       "89c15899f7f9"  ], ! mov cx,ax; pop ax; cwd;
						   ! idiv cx
		[ CG_MOD,       "89c15831d2f7f189d0"], ! mov ax,cx; pop ax
						   ! xor dx,dx; div cx
						   ! mov ax,dx
		[ CG_AND,       "5b21d8"        ], ! pop bx; and ax,bx
		[ CG_OR,        "5b09d8"        ], ! pop bx; or ax,bx
		[ CG_XOR,       "5b31d8"        ], ! pop bx; xor ax,bx
		[ CG_SHL,       "89c158d3e0"    ], ! mov cx,ax;pop ax;shl ax,cl
		[ CG_SHR,       "89c158d3e8"    ], ! mov cx,ax;pop ax;shr ax,cl
!               [ CG_EQ,        "31d25b39c375014a89d0"  ], ! xor dx,dx; pop bx
!               [ CG_NE,        "31d25b39c374014a89d0"  ], ! cmp bx,ax; j?? +3
!               [ CG_LT,        "31d25b39c37d014a89d0"  ], ! dec dx; mov ax,dx
!               [ CG_GT,        "31d25b39c37e014a89d0"  ], ! ??=ne,e,ge,le,g,l
!               [ CG_LE,        "31d25b39c37f014a89d0"  ],
!               [ CG_GE,        "31d25b39c37c014a89d0"  ],
		[ CG_EQ,        "e8,R2f01"      ], ! call $12f
		[ CG_NE,        "e8,R3201"      ], ! call $132
		[ CG_LT,        "e8,R3501"      ], ! call $135
		[ CG_GT,        "e8,R3801"      ], ! call $138
		[ CG_LE,        "e8,R3b01"      ], ! call $13b
		[ CG_GE,        "e8,R3e01"      ], ! call $13e
		[ CG_JMPEQ,     "5b39c37503e9,r"], ! pop bx; cmp bx,ax; jne +3
						   ! jmp R
		[ CG_JMPNE,     "5b39c37403e9,r"], ! ... je +3 ...
		[ CG_JMPLT,     "5b39c37d03e9,r"], ! ... jge +3 ...
		[ CG_JMPGT,     "5b39c37e03e9,r"], ! ... jle +3 ...
		[ CG_JMPLE,     "5b39c37f03e9,r"], ! ... jg +3 ...
		[ CG_JMPGE,     "5b39c37c03e9,r"], ! ... jl +3 ...
		[ CG_PUSHA,"505351521e5606571689e0404050"],
						   ! push ax,bx,cx,dx,ds,si,es
						   ! push di,ss;mov ax,sp;
						   ! inc ax;inc ax;push ax
		[ CG_POPA,
"8b5e06539d83f8007403f9eb01f89c5b895e065b58fa8ed089dcfb5f075e1f5a595b58"],
						   ! mov bx,[bp+6];push bx;popf
						   ! cmp ax,0;jz +3;stc;jmps+1
						   ! clc;pushf;pop bx;
						   ! mov [bp+6],bx
						   ! pop ax,bx;cli;mov ss,ax
						   ! mov sp,bx;sti;pop di,es
						   ! pop si,ds,dx,cx,bx,ax
		[ CG_DIVU,       "89c15831d2f7f1"], ! mov ax,cx; pop ax
						   ! xor dx,dx; div cx
		[ %1,           ""              ] ];
	Opttbl := [
		[ CG_EQ,        0,      CG_JMPFALSE,    CG_JMPNE        ],
		[ CG_NE,        0,      CG_JMPFALSE,    CG_JMPEQ        ],
		[ CG_LT,        0,      CG_JMPFALSE,    CG_JMPGE        ],
		[ CG_GT,        0,      CG_JMPFALSE,    CG_JMPLE        ],
		[ CG_LE,        0,      CG_JMPFALSE,    CG_JMPGT        ],
		[ CG_GE,        0,      CG_JMPFALSE,    CG_JMPLT        ],
		[ CG_LOGNOT,    0,      CG_JMPFALSE,    CG_JMPTRUE      ],
		[ %1,           %1,     %1,             %1              ],
		[ CG_LDVAL,     0,      CG_ADD,         CG_DROP         ],
		%1 ];
	Ops := [[ 7, 3, "mod",  BINOP,  CG_MOD          ],
		[ 6, 1, "+",    BINOP,  CG_ADD          ],
		[ 7, 1, "*",    BINOP,  CG_MUL          ],
		[ 0, 1, ";",    SEMI,   0               ],
		[ 0, 1, ",",    COMMA,  0               ],
		[ 0, 1, "(",    LPAREN, 0               ],
		[ 0, 1, ")",    RPAREN, 0               ],
		[ 0, 1, "[",    LBRACK, 0               ],
		[ 0, 1, "]",    RBRACK, 0               ],
		[ 3, 1, "=",    BINOP,  CG_EQ           ],
		[ 5, 1, "&",    BINOP,  CG_AND          ],
		[ 5, 1, "|",    BINOP,  CG_OR           ],
		[ 5, 1, "^",    BINOP,  CG_XOR          ],
		[ 0, 1, "@",    ADDROF, 0               ],
		[ 0, 1, "~",    UNOP,   CG_INV          ],
		[ 0, 1, ":",    COLON,  0               ],
		[ 0, 2, "::",   BYTEOP, 0               ],
		[ 0, 2, ":=",   ASSIGN, 0               ],
		[ 0, 1, "\\",   UNOP,   CG_LOGNOT       ],
		[ 1, 2, "\\/",  DISJ,   0               ],
		[ 3, 2, "\\=",  BINOP,  CG_NE           ],
		[ 4, 1, "<",    BINOP,  CG_LT           ],
		[ 4, 2, "<=",   BINOP,  CG_LE           ],
		[ 5, 2, "<<",   BINOP,  CG_SHL          ],
		[ 4, 1, ">",    BINOP,  CG_GT           ],
		[ 4, 2, ">=",   BINOP,  CG_GE           ],
		[ 5, 2, ">>",   BINOP,  CG_SHR          ],
		[ 6, 1, "-",    BINOP,  CG_SUB          ],
		[ 0, 2, "->",   COND,   0               ],
		[ 7, 1, "/",    BINOP,  CG_DIV          ],
		[ 7, 2, "./",   BINOP,  CG_DIVU         ],
		[ 2, 2, "/\\",  CONJ,   0               ],
		[ 0, 0, 0,      0,      0               ] ];
	Equal_op := findop("=");
	Minus_op := findop("-");
	Mul_op := findop("*");
	Add_op := findop("+");
	i := 0;
	while (Codetbl[i][0] \= %1) do
		if (Codetbl[i][0] \= i) do
			str_copy(b, ntoa(i));
			oops("bad code table entry", b);
		end
		i := i+1;
	end
	add("t3x.sysin", GLOB|CNST, 0);
	add("t3x.sysout", GLOB|CNST, 1);
	add("t3x.syserr", GLOB|CNST, 2);
	add("t3x.oread", GLOB|CNST, 0);
	add("t3x.owrite", GLOB|CNST, 1);
	add("t3x.oappnd", GLOB|CNST, 3);
	add("t3x.ptrsize", GLOB|CNST, 4);
	builtin("t.bpw", 0,     0x0108);
	builtin("t.newline", 1, 0x010b);
	builtin("t.memcomp", 3, 0x010e);
	builtin("t.memcopy", 3, 0x0111);
	builtin("t.memfill", 3, 0x0114);
	builtin("t.memscan", 3, 0x0117);
	builtin("t.getarg", 3,  0x011a);
	builtin("t.open", 2,    0x011d);
	builtin("t.close", 1,   0x0120);
	builtin("t.read", 3,    0x0123);
	builtin("t.write", 3,   0x0126);
	builtin("t.rename", 2,  0x0129);
	builtin("t.remove", 1,  0x012c);
	builtin("t.farcomp", 5, 0x0150);
	builtin("t.farcopy", 5, 0x0153);
	builtin("t.farfill", 4, 0x0156);
	builtin("t.farscan", 4, 0x0159);
	builtin("t.fargetb", 2, 0x015c);
	builtin("t.farsetb", 3, 0x015f);
	builtin("t.fargetw", 2, 0x0162);
	builtin("t.farsetw", 3, 0x0165);
	builtin("t.local", 0,   0x0168);
	builtin("t.outb", 2,    0x016b);
	builtin("t.inb", 1,     0x016e);
	builtin("t.outw", 2,    0x0171);
	builtin("t.inw", 1,     0x0174);
	builtin("t.int86c", 7,  0x0177);
	builtin("t.int86ax", 7, 0x017a);
	builtin("t.int86z", 7,  0x017d);
	builtin("t.setptr", 3,  0x0180);
	builtin("t.getseg", 1,  0x0183);
	builtin("t.getoff", 1,  0x0186);
	builtin("t.stack", 0,   0x0189);
	builtin("t.getflags", 0,0x018c);
	builtin("t.setflags", 1,0x018f);
	builtin("t.jmpstack", 3,0x0192);
	builtin("t.stackptr", 0,0x0195);
	builtin("t.instrptr", 0,0x0198);
	builtin("t.bochsbrk", 0,0x019b);
	builtin("t.farfillw", 4,0x019e);
	emitlib();
end

info() do
	writes("Text = ");
	writes(ntoa(Tp - 0x100));
	writes(", Data = ");
	writes(ntoa(Dp+622));
	writes(", Symbols = ");
	writes(ntoa(Yp/SYM));
	writes(", Nlist = ");
	writes(ntoa(Np));
	writes(", Labels = ");
	writes(ntoa(Lab));
	nl();
end

phase(in, n) do
	if (Verbose) do
		writes(n-> "Pass 2:": "Pass 1:");
		nl();
	end
	Infile := t.open(in, T3X.OREAD);
	if (Infile < 0) aw("no such file", in);
	Outfile := t.open(Outname, T3X.OWRITE);
	if (Outfile < 0) aw("cannot create", Outname);
	init(n);
	program();
	commit();
	t.close(Infile);
	flush();
	t.close(Outfile);
end

upcase(s) do var i;
	i := 0;
	while (s::i) do
		if ('a' <= s::i /\ s::i <= 'z')
			s::i := s::i-'a'+'A';
		i := i+1;
	end
	return s;
end

do var in::75, k;
	Outname::0 := 0;
	Verbose := 0;
	if (t.getarg(2, in, 4) \= %1 /\ str_equal(upcase(in), "/V"))
		Verbose := 1;
	k := t.getarg(1, in, 72);
	if (k < 0) aw("missing file name", 0);
	t.memcopy(@in::k, ".t", 3);
	str_copy(Outname, in);
	t.memcopy(@Outname::k, ".com", 5);
	phase(in, 0);
	phase(in, 1);
	info();
end
